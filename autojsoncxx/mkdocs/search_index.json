{
    "docs": [
        {
            "location": "/", 
            "text": "autojsoncxx\n\n\nA header-only library and a code generator to \nautomagically\n translate between \nJSON\n and \nC++\n types.\n\n\nOverview\n\n\nJSON is a popular format for data exchange. Reading and writing JSON in C++, however, is nontrivial. Even with the help of libraries, one still needs to write lots of boilerplate code, and it is extremely hard to guard against all possible errors, since JSON is dynamically typed while C++ employs static typing.\n\n\nMore importantly, manually writing such code is a violation of \nDRY\n principle. When manually written, the class definition, parsing and serialization code can easily become out of sync, leading to brittle code and subtle bugs.\n\n\nautojsoncxx\n is an attempt to solve this problem by automating such process.\n\n\nDependency\n\n\n\n\nRapidJSON\n\n\nPython\n (2.7 or 3.3+)\n\n\n(optional) \nParsimonious\n\n\n(optional) \nCatch\n\n\n(optional) \nBoost\n\n\n\n\nFeatures\n\n\n\n\nThe parsing/serializing code are \nautomagically\n generated.\n\n\nDetailed error message\n. Unlike ordinary JSON libraries, \nautojsoncxx\n will detect not only invalid JSON errors, but also mismatch between JSON value and C++ type specification.\n\n\nEase of use\n. A single function call is enough for most use cases. The library has no complicated build setup, since it's header only.\n\n\nFast\n. Based on the streaming API of \nrapidjson\n and C++ templates, this library is efficient both in space and time.\n\n\nFlexible\n. Whenever the support of a certain class \nFoo\n is added to the library, all the combination of types, like \nstd::vector\nFoo\n, \nstd::shared_ptr\nFoo\n, \nstd::deque\nstd::map\nstd::string, Foo\n is automatically supported as well, thanks to the use of template specialization.\n\n\nLiberal license\n. Both the library and its dependency are licensed liberally (MIT or BSD-like). Anyone is free to copy, distribute, modify or include in their own projects, be it open source or commercial.\n\n\n\n\nTesting\n\n\n\n\nTo build the test, you need a sufficiently new compiler because the goal is to test all the type support, including many ones only introduced in c++11.\n\n\nFirst clone the repository, and pull the dependency\n\n\ngit clone https://github.com/netheril96/autojsoncxx.git --recursive\n\n\n\n\nUNIX/Linux/Mac users\n:\n\n\ncmake .\nmake\nmake test\n\n\n\n\nWindows users\n:\n\n\nGenerate the \ntest/userdef.hpp\n file from the definition \nexamples/userdef.json\n. Then open the solution file under \ntest/mscvXX_test/\n to build and run the test.\n\n\nIf too many tests fail, make sure your work directory points to the \ntest\n directory.\n\n\nCurrently tested compilers\n\n\n\n\nClang 3.4/3.5 on Mac OS X (11.9)\n\n\nGCC 4.9 (Homebrew) on Mac OS X (11.9)\n\n\nClang 3.0 on Ubuntu 12.04 (x64)\n\n\nGCC 4.8 on Ubuntu 14.04.1 (x86/x64)\n\n\nMSVC 10 (x86) on Windows 7\n\n\nMSVC 11/12 (x86/x64) on Windows 7\n\n\n\n\nQuick start\n\n\nThe code generator reads a JSON file that defines the class structure. An example definition is like this\n\n\n{\n    \nname\n: \nPerson\n,\n    \nmembers\n:\n    [\n        [\nunsigned long long\n, \nID\n, {\nrequired\n: true}],\n        [\nstd::string\n, \nname\n, {\ndefault\n: \nanonymous\n}],\n        [\ndouble\n, \nheight\n],\n        [\ndouble\n, \nweight\n],\n        [\nstd::vector\nunsigned long long\n, \nknown_associates\n]\n    ]\n}\n\n\n\n\nRun the script \nautojsoncxx.py\n (requires Python 2.7+, including version 3+) on this definition file, and a header file will be generated. It includes a definition for \nPerson\n as well as some helper classes.\n\n\npython autojsoncxx.py --input=persondef.json --output=person.hpp\n\n\n\n\nSerialization\n\n\nPerson p;\nautojsoncxx::to_pretty_json_file(\nperson.json\n, p);\nautojsoncxx::to_json_file(stdout, p);\nautojsoncxx::to_json_string(std::make_shared\nPerson\n(p));\n\n\n\n\nParsing\n\n\nautojsoncxx::ParsingResult result;\nPerson p;\nif (!autojsoncxx::from_json_file(\nperson.json\n, p, result)) {\n    std::cerr \n result \n '\\n';\n    return -1;\n}\n\n\n\n\nError handling\n\n\nIf the JSON file is malformed, any decent JSON library will detect it and tell you what goes wrong. But what if the JSON value is perfectly valid, but not laid out the way you expected? Usually you have to manually check the DOM tree against your specification, but this library will automatically generates the necessary code.\n\n\nHere is valid JSON file\n\n\n{\n    \nname\n: \nMike\n,\n    \nID\n: 8940220481904,\n    \nheight\n: 1.77,\n    \nweight\n: 70.0,\n    \nknown_associates\n: [\n        \nJack\n, \nMary\n\n    ]\n}\n\n\n\n\nRunning through the parsing code, and you will get an error output:\n\n\nParsing failed at offset 127 with error code 16:\nTerminate parsing due to Handler error.\n\nTrace back (last call first):\n(*) Type mismatch between expected type \nuint64_t\n and actual type \nstring\n\n(*) Error at array element with index 0\n(*) Error at object member with name \nknown_associates\n\n\n\n\n\nOne can also \nquery the errors programmingly\n.\n\n\nDocumentation\n\n\nRead more \nhere\n.\n\n\nCredit\n\n\nThis project is inspired by \ngoogle protobuf\n. It adopts the same approach in protobuf (compiler + definition file), and borrows various parse options from it.", 
            "title": "Home"
        }, 
        {
            "location": "/#autojsoncxx", 
            "text": "A header-only library and a code generator to  automagically  translate between  JSON  and  C++  types.", 
            "title": "autojsoncxx"
        }, 
        {
            "location": "/#overview", 
            "text": "JSON is a popular format for data exchange. Reading and writing JSON in C++, however, is nontrivial. Even with the help of libraries, one still needs to write lots of boilerplate code, and it is extremely hard to guard against all possible errors, since JSON is dynamically typed while C++ employs static typing.  More importantly, manually writing such code is a violation of  DRY  principle. When manually written, the class definition, parsing and serialization code can easily become out of sync, leading to brittle code and subtle bugs.  autojsoncxx  is an attempt to solve this problem by automating such process.", 
            "title": "Overview"
        }, 
        {
            "location": "/#dependency", 
            "text": "RapidJSON  Python  (2.7 or 3.3+)  (optional)  Parsimonious  (optional)  Catch  (optional)  Boost", 
            "title": "Dependency"
        }, 
        {
            "location": "/#features", 
            "text": "The parsing/serializing code are  automagically  generated.  Detailed error message . Unlike ordinary JSON libraries,  autojsoncxx  will detect not only invalid JSON errors, but also mismatch between JSON value and C++ type specification.  Ease of use . A single function call is enough for most use cases. The library has no complicated build setup, since it's header only.  Fast . Based on the streaming API of  rapidjson  and C++ templates, this library is efficient both in space and time.  Flexible . Whenever the support of a certain class  Foo  is added to the library, all the combination of types, like  std::vector Foo ,  std::shared_ptr Foo ,  std::deque std::map std::string, Foo  is automatically supported as well, thanks to the use of template specialization.  Liberal license . Both the library and its dependency are licensed liberally (MIT or BSD-like). Anyone is free to copy, distribute, modify or include in their own projects, be it open source or commercial.", 
            "title": "Features"
        }, 
        {
            "location": "/#testing", 
            "text": "To build the test, you need a sufficiently new compiler because the goal is to test all the type support, including many ones only introduced in c++11.  First clone the repository, and pull the dependency  git clone https://github.com/netheril96/autojsoncxx.git --recursive  UNIX/Linux/Mac users :  cmake .\nmake\nmake test  Windows users :  Generate the  test/userdef.hpp  file from the definition  examples/userdef.json . Then open the solution file under  test/mscvXX_test/  to build and run the test.  If too many tests fail, make sure your work directory points to the  test  directory.", 
            "title": "Testing"
        }, 
        {
            "location": "/#currently-tested-compilers", 
            "text": "Clang 3.4/3.5 on Mac OS X (11.9)  GCC 4.9 (Homebrew) on Mac OS X (11.9)  Clang 3.0 on Ubuntu 12.04 (x64)  GCC 4.8 on Ubuntu 14.04.1 (x86/x64)  MSVC 10 (x86) on Windows 7  MSVC 11/12 (x86/x64) on Windows 7", 
            "title": "Currently tested compilers"
        }, 
        {
            "location": "/#quick-start", 
            "text": "The code generator reads a JSON file that defines the class structure. An example definition is like this  {\n     name :  Person ,\n     members :\n    [\n        [ unsigned long long ,  ID , { required : true}],\n        [ std::string ,  name , { default :  anonymous }],\n        [ double ,  height ],\n        [ double ,  weight ],\n        [ std::vector unsigned long long ,  known_associates ]\n    ]\n}  Run the script  autojsoncxx.py  (requires Python 2.7+, including version 3+) on this definition file, and a header file will be generated. It includes a definition for  Person  as well as some helper classes.  python autojsoncxx.py --input=persondef.json --output=person.hpp", 
            "title": "Quick start"
        }, 
        {
            "location": "/#serialization", 
            "text": "Person p;\nautojsoncxx::to_pretty_json_file( person.json , p);\nautojsoncxx::to_json_file(stdout, p);\nautojsoncxx::to_json_string(std::make_shared Person (p));", 
            "title": "Serialization"
        }, 
        {
            "location": "/#parsing", 
            "text": "autojsoncxx::ParsingResult result;\nPerson p;\nif (!autojsoncxx::from_json_file( person.json , p, result)) {\n    std::cerr   result   '\\n';\n    return -1;\n}", 
            "title": "Parsing"
        }, 
        {
            "location": "/#error-handling", 
            "text": "If the JSON file is malformed, any decent JSON library will detect it and tell you what goes wrong. But what if the JSON value is perfectly valid, but not laid out the way you expected? Usually you have to manually check the DOM tree against your specification, but this library will automatically generates the necessary code.  Here is valid JSON file  {\n     name :  Mike ,\n     ID : 8940220481904,\n     height : 1.77,\n     weight : 70.0,\n     known_associates : [\n         Jack ,  Mary \n    ]\n}  Running through the parsing code, and you will get an error output:  Parsing failed at offset 127 with error code 16:\nTerminate parsing due to Handler error.\n\nTrace back (last call first):\n(*) Type mismatch between expected type  uint64_t  and actual type  string \n(*) Error at array element with index 0\n(*) Error at object member with name  known_associates   One can also  query the errors programmingly .", 
            "title": "Error handling"
        }, 
        {
            "location": "/#documentation", 
            "text": "Read more  here .", 
            "title": "Documentation"
        }, 
        {
            "location": "/#credit", 
            "text": "This project is inspired by  google protobuf . It adopts the same approach in protobuf (compiler + definition file), and borrows various parse options from it.", 
            "title": "Credit"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\nCode generation\n\n\nThe code generator reads a JSON file that defines the class structure. An example definition is like this (remember to fully qualify the type name with its namespace)\n\n\n{\n    \nname\n: \nPerson\n,\n    \nmembers\n:\n    [\n        [\nunsigned long long\n, \nID\n, {\nrequired\n: true}],\n        [\nstd::string\n, \nname\n, {\ndefault\n: \nanonymous\n}],\n        [\ndouble\n, \nheight\n],\n        [\ndouble\n, \nweight\n],\n        [\nstd::vector\nunsigned long long\n, \nknown_associates\n]\n    ]\n}\n\n\n\n\nRun the script \nautojsoncxx.py\n (requires Python 2.7+, including version 3+) on this definition file, and a header file will be generated. It includes a definition for \nPerson\n as well as some helper classes. The \nPerson\n is a \nstruct\n with all members public, meant as a data holder without any additional functionalities. It can be used with free functions, or \nwrapped up in another class to provide encapsulation and polymorphism\n.\n\n\npython autojsoncxx.py --input=persondef.json --output=person.hpp\n\n\n\n\nRemember to add the include directory of \nautojsoncxx\n and \nrapidjson\n to your project header search path (no linking is required).\n\n\nThe below examples uses c++11 features, but the library also works with c++03 compilers (provided you do not use new classes from c++11).\n\n\nSerialization\n\n\n#define AUTOJSONCXX_MODERN_COMPILER 1 // Turn on all the c++11 features of the library\n#include \niostream\n\n#include \nperson.hpp\n\n\nint main()\n{\n    Person p;\n    p.name = \nMike\n;\n    p.ID = 8940220481904ULL;\n    p.weight = 70;\n    p.height = 1.77;\n    p.known_associates = { 149977889346362, 90000134866608, 44412567664 };\n    // Use successive push_back() if your compiler is not c++11 ready\n\n    autojsoncxx::to_pretty_json_file(\nperson.json\n, p);\n    return 0;\n}\n\n\n\n\nThis will generate a file \nperson.json\n with contents below:\n\n\n{\n    \nname\n: \nMike\n,\n    \nID\n: 8940220481904,\n    \nheight\n: 1.77,\n    \nweight\n: 70.0,\n    \nknown_associates\n: [\n        149977889346362,\n        90000134866608,\n        44412567664\n    ]\n}\n\n\n\n\nParsing\n\n\nNow let's try read that back\n\n\n#define AUTOJSONCXX_MODERN_COMPILER 1\n#include \niostream\n\n#include \nperson.hpp\n\n\nint main()\n{\n    autojsoncxx::ParsingResult result;\n    Person p;\n    if (!autojsoncxx::from_json_file(\nperson.json\n, p, result)) {\n        std::cerr \n result \n '\\n';\n        return -1;\n    }\n\n    std::cout \n \nID: \n \n p.ID \n '\\n'\n              \n \nname:  \n \n p.name \n '\\n'\n              \n \nheight: \n \n p.height \n '\\n'\n              \n \nweight: \n \n p.weight \n '\\n';\n\n    std::cout \n \nknown associates: \n;\n    for (auto\n id : p.known_associates)\n        std::cout \n id \n '\\t';\n    std::cout \n '\\n';\n    return 0;\n}\n\n\n\n\nError handling\n\n\nAny decent JSON library can detect and report errors resulting from a invalid JSON. In addition, \nautojsoncxx\n will detect and stop processing once the JSON value does not match the C++ type specification. This enforces the static typing of C++ on the dynamic JSON, and can be seen as a limited form of JSON schema.\n\n\nHere is valid JSON file\n\n\n{\n    \nname\n: \nMike\n,\n    \nID\n: 8940220481904,\n    \nheight\n: 1.77,\n    \nweight\n: 70.0,\n    \nknown_associates\n: [\n        \nJack\n, \nMary\n\n    ]\n}\n\n\n\n\nRunning through the parsing code, and you will get an error output:\n\n\nParsing failed at offset 127 with error code 16:\nTerminate parsing due to Handler error.\n\nTrace back (last call first):\n(*) Type mismatch between expected type \nuint64_t\n and actual type \nstring\n\n(*) Error at array element with index 0\n(*) Error at object member with name \nknown_associates\n\n\n\n\n\nYou can also \nprogrammingly examine the error\n.\n\n\nMore complex types\n\n\nThe design of \nautojsoncxx\n makes it possible to read/write not only the class generated, but also the combination of all supported types. That is, you can also call the \nto_json\n and \nfrom_json\n family of functions on \nstd::vector\nPerson\n, \nstd::map\nstd::string, Person\n, \nstd::shared_ptr\nPerson\n, or even more complicated ones like \nstd::tuple\nstd::string, double, Person, std::deque\nint\n, std::vector\nstd::unique_ptr\nPerson\n, bool\n.\n\n\nThis also makes it possible to build more complex types. For example, the definition file can be written as\n\n\n[\n    {\n        \nname\n: \nPerson\n,\n        \nmembers\n:\n        [\n            [\nunsigned long long\n, \nID\n, {\nrequired\n: true}],\n            [\nstd::string\n, \nname\n, {\ndefault\n: \nanonymous\n}],\n            [\ndouble\n, \nheight\n],\n            [\ndouble\n, \nweight\n],\n            [\nstd::vector\nunsigned long long\n, \nknown_associates\n]\n        ]\n    },\n    {\n        \nname\n: \nGroup\n,\n        \nmembers\n:\n        [\n            [\nunsigned long long\n, \nGroupID\n, {\nrequired\n: true}],\n            [\nstd::string\n, \nname\n],\n            [\nstd::vector\nstd::shared_ptr\nPerson\n, \npersons\n]\n        ]\n    }\n]\n\n\n\n\nSo you have another struct that contains \nPerson\n as a member.\n\n\nDOM support\n\n\nautojsoncxx\n is based on streams, which is efficient both in time and space. However, maybe sometimes Document Object Model is desired. One can convert types supported by \nautojsoncxx\n to/from \nrapidjson::Document\n directly through free functions \nto_document\n and \nfrom_document\n.\n\n\nIn addition, \nrapidjson::Document\n is supported the same as \nint\n or \nstd::map\n, so it can be the type of class members. This makes it possible to intermix static typing and dynamic typing.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#code-generation", 
            "text": "The code generator reads a JSON file that defines the class structure. An example definition is like this (remember to fully qualify the type name with its namespace)  {\n     name :  Person ,\n     members :\n    [\n        [ unsigned long long ,  ID , { required : true}],\n        [ std::string ,  name , { default :  anonymous }],\n        [ double ,  height ],\n        [ double ,  weight ],\n        [ std::vector unsigned long long ,  known_associates ]\n    ]\n}  Run the script  autojsoncxx.py  (requires Python 2.7+, including version 3+) on this definition file, and a header file will be generated. It includes a definition for  Person  as well as some helper classes. The  Person  is a  struct  with all members public, meant as a data holder without any additional functionalities. It can be used with free functions, or  wrapped up in another class to provide encapsulation and polymorphism .  python autojsoncxx.py --input=persondef.json --output=person.hpp  Remember to add the include directory of  autojsoncxx  and  rapidjson  to your project header search path (no linking is required).  The below examples uses c++11 features, but the library also works with c++03 compilers (provided you do not use new classes from c++11).", 
            "title": "Code generation"
        }, 
        {
            "location": "/tutorial/#serialization", 
            "text": "#define AUTOJSONCXX_MODERN_COMPILER 1 // Turn on all the c++11 features of the library\n#include  iostream \n#include  person.hpp \n\nint main()\n{\n    Person p;\n    p.name =  Mike ;\n    p.ID = 8940220481904ULL;\n    p.weight = 70;\n    p.height = 1.77;\n    p.known_associates = { 149977889346362, 90000134866608, 44412567664 };\n    // Use successive push_back() if your compiler is not c++11 ready\n\n    autojsoncxx::to_pretty_json_file( person.json , p);\n    return 0;\n}  This will generate a file  person.json  with contents below:  {\n     name :  Mike ,\n     ID : 8940220481904,\n     height : 1.77,\n     weight : 70.0,\n     known_associates : [\n        149977889346362,\n        90000134866608,\n        44412567664\n    ]\n}", 
            "title": "Serialization"
        }, 
        {
            "location": "/tutorial/#parsing", 
            "text": "Now let's try read that back  #define AUTOJSONCXX_MODERN_COMPILER 1\n#include  iostream \n#include  person.hpp \n\nint main()\n{\n    autojsoncxx::ParsingResult result;\n    Person p;\n    if (!autojsoncxx::from_json_file( person.json , p, result)) {\n        std::cerr   result   '\\n';\n        return -1;\n    }\n\n    std::cout    ID:     p.ID   '\\n'\n                 name:      p.name   '\\n'\n                 height:     p.height   '\\n'\n                 weight:     p.weight   '\\n';\n\n    std::cout    known associates:  ;\n    for (auto  id : p.known_associates)\n        std::cout   id   '\\t';\n    std::cout   '\\n';\n    return 0;\n}", 
            "title": "Parsing"
        }, 
        {
            "location": "/tutorial/#error-handling", 
            "text": "Any decent JSON library can detect and report errors resulting from a invalid JSON. In addition,  autojsoncxx  will detect and stop processing once the JSON value does not match the C++ type specification. This enforces the static typing of C++ on the dynamic JSON, and can be seen as a limited form of JSON schema.  Here is valid JSON file  {\n     name :  Mike ,\n     ID : 8940220481904,\n     height : 1.77,\n     weight : 70.0,\n     known_associates : [\n         Jack ,  Mary \n    ]\n}  Running through the parsing code, and you will get an error output:  Parsing failed at offset 127 with error code 16:\nTerminate parsing due to Handler error.\n\nTrace back (last call first):\n(*) Type mismatch between expected type  uint64_t  and actual type  string \n(*) Error at array element with index 0\n(*) Error at object member with name  known_associates   You can also  programmingly examine the error .", 
            "title": "Error handling"
        }, 
        {
            "location": "/tutorial/#more-complex-types", 
            "text": "The design of  autojsoncxx  makes it possible to read/write not only the class generated, but also the combination of all supported types. That is, you can also call the  to_json  and  from_json  family of functions on  std::vector Person ,  std::map std::string, Person ,  std::shared_ptr Person , or even more complicated ones like  std::tuple std::string, double, Person, std::deque int , std::vector std::unique_ptr Person , bool .  This also makes it possible to build more complex types. For example, the definition file can be written as  [\n    {\n         name :  Person ,\n         members :\n        [\n            [ unsigned long long ,  ID , { required : true}],\n            [ std::string ,  name , { default :  anonymous }],\n            [ double ,  height ],\n            [ double ,  weight ],\n            [ std::vector unsigned long long ,  known_associates ]\n        ]\n    },\n    {\n         name :  Group ,\n         members :\n        [\n            [ unsigned long long ,  GroupID , { required : true}],\n            [ std::string ,  name ],\n            [ std::vector std::shared_ptr Person ,  persons ]\n        ]\n    }\n]  So you have another struct that contains  Person  as a member.", 
            "title": "More complex types"
        }, 
        {
            "location": "/tutorial/#dom-support", 
            "text": "autojsoncxx  is based on streams, which is efficient both in time and space. However, maybe sometimes Document Object Model is desired. One can convert types supported by  autojsoncxx  to/from  rapidjson::Document  directly through free functions  to_document  and  from_document .  In addition,  rapidjson::Document  is supported the same as  int  or  std::map , so it can be the type of class members. This makes it possible to intermix static typing and dynamic typing.", 
            "title": "DOM support"
        }, 
        {
            "location": "/user_guide/definition_file_syntax/", 
            "text": "Definition file syntax\n\n\nThe definition file is a simple JSON file that lists all the classes, their members as well as options to control the parsing. The root must be an object corresponding to a class definition, or an array of such objects.\n\n\nClass definition\n\n\nA class definition is an object with the following fields:\n\n\n\n\nname\n. The unqualified name of the class.\n\n\nnamespace\n. (optional). The full namespace of this class, such as \nmycompany::data\n or \n::mycompany::data\n. When not set, the class is put in the global namespace.\n\n\nparse_mode\n (optional). \"strict\" or otherwise, default \"\". When set to strict, any unrecognized JSON key will cause an \nUnknownFieldError\n. Otherwise they are simply ignored. The default is ignoring, so that you can upgrade your protocol by appending new fields without affecting old applications.\n\n\nno_duplicates\n (optional). When true, an error is raised if any duplicate field is encountered. Otherwise the last occurrence will be retained.\n\n\nconstructor_code\n. (optional). Arbitrary C++ code to execute in the constructor, useful if you need to perform initialization that cannot be done with the \ndefault\n option.\n\n\ncomment\n (optional). Ignored.\n\n\nmembers\n. An array of member definitions.\n\n\n\n\nMember definition\n\n\nA member definition is a JSON array of two or three elements. The first two is \"positional arguments\", referring to the \nfully qualified\n type name and the variable name, mimicking the declaration order in C++. The third element, if any, is a JSON object with one or more of the following keys:\n\n\n\n\nrequired\n. true/false (default: false). When set to true, the lack of such field in the JSON triggers \nMissingFieldError\n. If you want to know whether a certain key is present but not wanting the errors, you can use a nullable wrapper.\n\n\ndefault\n. A boolean, number or string, used to initialize this field. When not set, the field is value initialized in the constructor.\n\n\njson_key\n. The corresponding key in JSON. When not set, it is the same as the variable name.\n\n\ncomment\n. Ignored.", 
            "title": "Definition file syntax"
        }, 
        {
            "location": "/user_guide/definition_file_syntax/#definition-file-syntax", 
            "text": "The definition file is a simple JSON file that lists all the classes, their members as well as options to control the parsing. The root must be an object corresponding to a class definition, or an array of such objects.", 
            "title": "Definition file syntax"
        }, 
        {
            "location": "/user_guide/definition_file_syntax/#class-definition", 
            "text": "A class definition is an object with the following fields:   name . The unqualified name of the class.  namespace . (optional). The full namespace of this class, such as  mycompany::data  or  ::mycompany::data . When not set, the class is put in the global namespace.  parse_mode  (optional). \"strict\" or otherwise, default \"\". When set to strict, any unrecognized JSON key will cause an  UnknownFieldError . Otherwise they are simply ignored. The default is ignoring, so that you can upgrade your protocol by appending new fields without affecting old applications.  no_duplicates  (optional). When true, an error is raised if any duplicate field is encountered. Otherwise the last occurrence will be retained.  constructor_code . (optional). Arbitrary C++ code to execute in the constructor, useful if you need to perform initialization that cannot be done with the  default  option.  comment  (optional). Ignored.  members . An array of member definitions.", 
            "title": "Class definition"
        }, 
        {
            "location": "/user_guide/definition_file_syntax/#member-definition", 
            "text": "A member definition is a JSON array of two or three elements. The first two is \"positional arguments\", referring to the  fully qualified  type name and the variable name, mimicking the declaration order in C++. The third element, if any, is a JSON object with one or more of the following keys:   required . true/false (default: false). When set to true, the lack of such field in the JSON triggers  MissingFieldError . If you want to know whether a certain key is present but not wanting the errors, you can use a nullable wrapper.  default . A boolean, number or string, used to initialize this field. When not set, the field is value initialized in the constructor.  json_key . The corresponding key in JSON. When not set, it is the same as the variable name.  comment . Ignored.", 
            "title": "Member definition"
        }, 
        {
            "location": "/user_guide/error_handling/", 
            "text": "Error handling\n\n\nClasses\n\n\nAll the classes relevant to error handling are in namespace \nautojsoncxx::error\n.\n\n\nErrorBase\n\n\nThis is the base of all error classes that denote a mismatch between JSON value and C++ specification. It exposes two public API, both declared \nconst\n:\n\n\n\n\ntype()\n: returns an integer denoting the runtime type of this error\n\n\ndescription()\n: returns a human readable description of the error.\n\n\n\n\nTo examine the actual payload with the error, it must be cast to one of its subclasses based on its type. The current types include:\n\n\nSUCCESS = 0,\nOBJECT_MEMBER = 1,\nARRAY_ELEMENT = 2,\nMISSING_REQUIRED = 3,\nTYPE_MISMATCH = 4,\nNUMBER_OUT_OF_RANGE = 5,\nARRAY_LENGTH_MISMATCH = 6,\nUNKNOWN_FIELD = 7,\nDUPLICATE_KEYS = 8,\nCORRUPTED_DOM = 9;\n\n\n\n\nErrorStack\n\n\nThis is an intrusive stack of chained \nErrorBase\n and thus noncopyable. Users should only query its const methods, which are compatible with STL classes: \nbegin()\n and \nend()\n that returns an iterator to \nErrorBase\n; \nempty()\n and \nsize()\n for the information about the container.\n\n\nParsingResult\n\n\nThis class is also in namespace \nautojsoncxx\n. It combines the error information from \nrapidjson\n and the \nErrorStack\n. Relevant methods:\n\n\n\n\nerror_code()\n\n\noffset()\n\n\nerror_stack()\n\n\ndescription()\n\n\n\n\nIt can also be iterated over, a shorthand for iterating over the stack embedded within.\n\n\nExample\n\n\nCall \nerror_code()\n and \noffset()\n to examine it. When \nerror_code() == rapidjson::kParseErrorTermination\n, you can also iterate over the \nautojsoncxx::ParsingResult\n object for any errors resulting from mapping JSON to C++ types; otherwise the error is a result of malformed JSON, such as missing coma, invalid escape sequence, etc.\n\n\nif (!result.has_error())\n    return;\n\n// equivalent: if (result.error_stack().empty())\nif (result.error_code() != rapidjson::kParseErrorTermination)\n{\n    std::cerr \n \nMalformed JSON: \n \n result.short_description() \n '\\n';\n    return;\n}\n\n// equivalent: for (auto\n e: result.error_stack())\nfor (auto\n e : result) {\n    using namespace autojsoncxx::error;\n\n    switch (e.type()) {\n\n    case UNKNOWN_FIELD: {\n        const UnknownFieldError\n err = static_cast\nconst UnknownFieldError\n(e);\n        if (err.field_name().find(\nVersion\n) != std::string::npos)\n            std::cerr \n \nThis is a definition of different protocol version\\n\n;\n    } break;\n\n    case NUMBER_OUT_OF_RANGE:\n        std::cerr \n \nMaybe you should use a 64-bit integer type instead?\\n\n;\n        break;\n\n    case TYPE_MISMATCH: {\n        const TypeMismatchError\n err = static_cast\nconst TypeMismatchError\n(e);\n        std::cout \n \ndon't you dare use a \n \n err.actual_type()\n                  \n \n to fool me!\\n\n;\n    } break;\n\n    case OBJECT_MEMBER: {\n        const ObjectMemberError\n err = static_cast\nconst ObjectMemberError\n(e);\n        std::cout \n \nThe member \n \n err.member_name() \n \n is naughty!\\n\n;\n    } break;\n\n    // Many more types of error has been defined, but not shown here for simplicity\n\n    default:\n        break;\n    }\n}", 
            "title": "Error handling"
        }, 
        {
            "location": "/user_guide/error_handling/#error-handling", 
            "text": "", 
            "title": "Error handling"
        }, 
        {
            "location": "/user_guide/error_handling/#classes", 
            "text": "All the classes relevant to error handling are in namespace  autojsoncxx::error .", 
            "title": "Classes"
        }, 
        {
            "location": "/user_guide/error_handling/#errorbase", 
            "text": "This is the base of all error classes that denote a mismatch between JSON value and C++ specification. It exposes two public API, both declared  const :   type() : returns an integer denoting the runtime type of this error  description() : returns a human readable description of the error.   To examine the actual payload with the error, it must be cast to one of its subclasses based on its type. The current types include:  SUCCESS = 0,\nOBJECT_MEMBER = 1,\nARRAY_ELEMENT = 2,\nMISSING_REQUIRED = 3,\nTYPE_MISMATCH = 4,\nNUMBER_OUT_OF_RANGE = 5,\nARRAY_LENGTH_MISMATCH = 6,\nUNKNOWN_FIELD = 7,\nDUPLICATE_KEYS = 8,\nCORRUPTED_DOM = 9;", 
            "title": "ErrorBase"
        }, 
        {
            "location": "/user_guide/error_handling/#errorstack", 
            "text": "This is an intrusive stack of chained  ErrorBase  and thus noncopyable. Users should only query its const methods, which are compatible with STL classes:  begin()  and  end()  that returns an iterator to  ErrorBase ;  empty()  and  size()  for the information about the container.", 
            "title": "ErrorStack"
        }, 
        {
            "location": "/user_guide/error_handling/#parsingresult", 
            "text": "This class is also in namespace  autojsoncxx . It combines the error information from  rapidjson  and the  ErrorStack . Relevant methods:   error_code()  offset()  error_stack()  description()   It can also be iterated over, a shorthand for iterating over the stack embedded within.", 
            "title": "ParsingResult"
        }, 
        {
            "location": "/user_guide/error_handling/#example", 
            "text": "Call  error_code()  and  offset()  to examine it. When  error_code() == rapidjson::kParseErrorTermination , you can also iterate over the  autojsoncxx::ParsingResult  object for any errors resulting from mapping JSON to C++ types; otherwise the error is a result of malformed JSON, such as missing coma, invalid escape sequence, etc.  if (!result.has_error())\n    return;\n\n// equivalent: if (result.error_stack().empty())\nif (result.error_code() != rapidjson::kParseErrorTermination)\n{\n    std::cerr    Malformed JSON:     result.short_description()   '\\n';\n    return;\n}\n\n// equivalent: for (auto  e: result.error_stack())\nfor (auto  e : result) {\n    using namespace autojsoncxx::error;\n\n    switch (e.type()) {\n\n    case UNKNOWN_FIELD: {\n        const UnknownFieldError  err = static_cast const UnknownFieldError (e);\n        if (err.field_name().find( Version ) != std::string::npos)\n            std::cerr    This is a definition of different protocol version\\n ;\n    } break;\n\n    case NUMBER_OUT_OF_RANGE:\n        std::cerr    Maybe you should use a 64-bit integer type instead?\\n ;\n        break;\n\n    case TYPE_MISMATCH: {\n        const TypeMismatchError  err = static_cast const TypeMismatchError (e);\n        std::cout    don't you dare use a     err.actual_type()\n                      to fool me!\\n ;\n    } break;\n\n    case OBJECT_MEMBER: {\n        const ObjectMemberError  err = static_cast const ObjectMemberError (e);\n        std::cout    The member     err.member_name()     is naughty!\\n ;\n    } break;\n\n    // Many more types of error has been defined, but not shown here for simplicity\n\n    default:\n        break;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/user_guide/miscellaneous/", 
            "text": "Miscellaneous\n\n\nMemory handling and exceptions\n\n\nException handling (\nthrow\n, \ntry\n, \ncatch\n) is not used by this library, to accommodate the needs of fake C++ programmers. It is designed, however, to be exception safe by using RAII wrappers to do all resource management. Copy, move constructor/assignment operator are disabled at certain places to avoid ownership mismanagement.\n\n\nNotably, the \nParsingResult\n class is not copyable. This simplifies the memory handling because it fully owns the error stack. It is movable, however, if you define \nAUTOJSONCXX_HAS_RVALUE\n. If you ever need to pass it around or store it somewhere, the simplest way is to use a shared pointer.\n\n\nC++11 features\n\n\nA set of macros control the usage of c++11 features. Define these macros as nonzero constants \nbefore\n inclusion, or define it in your build system.\n\n\n\n\nAUTOJSONCXX_MODERN_COMPILER\n: turn on all of the below\n\n\nAUTOJSONCXX_HAS_MODERN_TYPES\n: add support for c++11 new types, such as \nstd::shared_ptr\n.\n\n\nAUTOJSONCXX_HAS_RVALUE\n: enable the use of r-value references and move semantic.\n\n\nAUTOJSONCXX_HAS_NOEXCEPT\n: enable the use of keyword \nnoexcept\n and the function \nstd::move_if_noexcept()\n.\n\n\nAUTOJSONCXX_HAS_VARIADIC_TEMPLATE\n: enable the use of variadic templates. required if \nstd::tuple\n is used.\n\n\nAUTOJSONCXX_HAS_EXPLICIT_OPERATOR\n: enable the use of \nexplicit operator bool()\n. Otherwise no conversion to bool operator is defined.\n\n\n\n\nThe 64-bit integer type \nlong long\n and \nunsigned long long\n is always required. Though not in C++03 standard, most compilers support it nonetheless.\n\n\nEncoding\n\n\nThe default encoding is \nUTF-8\n. If you need to read/write JSON in \nUTF-16\n or \nUTF-32\n, instantiate the class \nSAXEventHandler\n and/or \nSerializer\n, and use it in combination with RapidJSON's transcoding capability.", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/user_guide/miscellaneous/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/user_guide/miscellaneous/#memory-handling-and-exceptions", 
            "text": "Exception handling ( throw ,  try ,  catch ) is not used by this library, to accommodate the needs of fake C++ programmers. It is designed, however, to be exception safe by using RAII wrappers to do all resource management. Copy, move constructor/assignment operator are disabled at certain places to avoid ownership mismanagement.  Notably, the  ParsingResult  class is not copyable. This simplifies the memory handling because it fully owns the error stack. It is movable, however, if you define  AUTOJSONCXX_HAS_RVALUE . If you ever need to pass it around or store it somewhere, the simplest way is to use a shared pointer.", 
            "title": "Memory handling and exceptions"
        }, 
        {
            "location": "/user_guide/miscellaneous/#c11-features", 
            "text": "A set of macros control the usage of c++11 features. Define these macros as nonzero constants  before  inclusion, or define it in your build system.   AUTOJSONCXX_MODERN_COMPILER : turn on all of the below  AUTOJSONCXX_HAS_MODERN_TYPES : add support for c++11 new types, such as  std::shared_ptr .  AUTOJSONCXX_HAS_RVALUE : enable the use of r-value references and move semantic.  AUTOJSONCXX_HAS_NOEXCEPT : enable the use of keyword  noexcept  and the function  std::move_if_noexcept() .  AUTOJSONCXX_HAS_VARIADIC_TEMPLATE : enable the use of variadic templates. required if  std::tuple  is used.  AUTOJSONCXX_HAS_EXPLICIT_OPERATOR : enable the use of  explicit operator bool() . Otherwise no conversion to bool operator is defined.   The 64-bit integer type  long long  and  unsigned long long  is always required. Though not in C++03 standard, most compilers support it nonetheless.", 
            "title": "C++11 features"
        }, 
        {
            "location": "/user_guide/miscellaneous/#encoding", 
            "text": "The default encoding is  UTF-8 . If you need to read/write JSON in  UTF-16  or  UTF-32 , instantiate the class  SAXEventHandler  and/or  Serializer , and use it in combination with RapidJSON's transcoding capability.", 
            "title": "Encoding"
        }, 
        {
            "location": "/user_guide/type_support/", 
            "text": "Type support\n\n\nPredefined types\n\n\nStandard library\n\n\nThese types are supported by this library:\n\n\n\n\nBasic types: \nbool\n, \nchar\n, \nint\n, \nunsigned int\n, \nlong long\n, \nunsigned long long\n, \nstd::string\n\n\nArray types: \nstd::vector\n, \nstd::deque\n, \nstd::array\n, \nstd::tuple\n (this one needs special care)\n\n\nNullable types: \nstd::nullptr_t\n, \nstd::unique_ptr\n, \nstd::shared_ptr\n\n\nMap types: \nstd::map\n, \nstd::unordered_map\n, \nstd::multimap\n, \nstd::unordered_multimap\n (The key must be of string type)\n\n\nObject types: any class generated by the script \nautojsoncxx.py\n.\n\n\nDOM: \nrapidjson::Document\n\n\n\n\nNotes: \n\n\n\n\nchar\n is mapped to JSON \nBoolean\n type, the same as \nbool\n. \n\n\n\n\nBoost\n\n\nIf you include \nautojsoncxx/boost_types.hpp\n (a relatively new \nboost\n is required), you will also get support for\n\n\n\n\nArray types: \nboost::container::vector\n, \nboost::container::deque\n, \nboost::array\n\n\nNullable types: \nboost::shared_ptr\n, \nboost::optional\n\n\nMap types: \nboost::unordered_map\n, \nboost::unordered_multimap\n (The key must be of string type)\n\n\n\n\nCaveat\n\n\nNo raw pointer and reference types are supported. Use smart pointers instead\n. They do not convey any information about ownership, and will make correct memory management (especially by a code generator) much more difficult.\n\n\nNested types\n\n\nThe supported types can be arbitrarily nested, for example\n\n\n#define AUTOJSONCXX_MODERN_COMPILER 1 \n#include \niostream\n\n#include \nperson.hpp\n\n\nint main()\n{\n    auto test = std::make_tuple(std::vector\nstd::string\n{ \nA\n, \nBC\n, \nDEF\n }, nullptr,\n                                3.1415926, -223, std::shared_ptr\nint\n(),\n                                std::map\nstd::string, bool\n{ { \na\n, true }, \n                                                           { \n\u0394\n, false } },\n                                std::make_shared\nstd::array\nPerson, 2\n());\n\n    std::string str;\n\n    // This requires true variadic template support \n    // MSVC 2012 has std::tuple\n, but it is faked with macros\n    // Avoid std::tuple\n if your compiler is not strong enough\n    autojsoncxx::to_pretty_json_string(str, test);\n\n    std::cout \n str \n '\\n';\n    return 0;\n}\n\n\n\n\nSample output\n\n\n[\n    [\n        \nA\n,\n        \nBC\n,\n        \nDEF\n\n    ],\n    null,\n    3.1415926,\n    -223,\n    null,\n    {\n        \na\n: true,\n        \n\u0394\n: false\n    },\n    [\n        {\n            \nID\n: 0,\n            \nname\n: \nanonymous\n,\n            \nheight\n: 0.0,\n            \nweight\n: 0.0,\n            \nknown_associates\n: []\n        },\n        {\n            \nID\n: 0,\n            \nname\n: \nanonymous\n,\n            \nheight\n: 0.0,\n            \nweight\n: 0.0,\n            \nknown_associates\n: []\n        }\n    ]\n]\n\n\n\n\nSelf defined type\n\n\nThe core of the library is two template class, \nSAXEventHandler\n and \nSerializer\n. The base templates are defined as:\n\n\nnamespace autojsoncxx {\n\n// The core handlers for parsing\ntemplate \nclass T\n\nclass SAXEventHandler;\n\n// Only the second parameter should be specialized\ntemplate \nclass Writer, class T\n\nstruct Serializer;\n\n}\n\n\n\n\nEach of the full or partial specialization of these templates will add new type support to the library. \n\n\nWriting the handler is somewhat difficult, because there are a multitude of errors that can result from a mismatched JSON. So there is some base classes provided, based on \nCuriously Recurring Template Pattern\n. For primitive types, such as a simple variant of \nint\n and \nbool\n, or string types (\nQString\n, \nCString\n, \nicu::UnicodeString\n, \nYetAnotherStringThatIsSoMuchBetterThanTheRest\n), derive from \nBaseSAXEventHandler\n. There are also base classes for array type \nVectorBaseSAXEventHandler\n, nullable type \nNullableBaseSAXEventHandler\n, map type \nMapBaseSAXEventHandler\n. If you implement your own string, you probably want to add map type support as well, because the default implementation is specialized on \nstd::string\n.\n\n\nWriting the serializer is very easy, and one can easily figure it out by looking at the source code.\n\n\nSpecial types\n\n\nTuple\n\n\nThere are only one tuple type supported \nstd::tuple\n (\nboost::tuple\n is not supported). Implementing it requires true variadic templates. If you want to use it, you need to define both \nAUTOJSONCXX_HAS_MODERN_TYPES\n and \nAUTOJSONCXX_HAS_VARIADIC_TEMPLATE\n to be nonzero. The macro \nAUTOJSONCXX_MODERN_COMPILER\n automatically turns on both two.\n\n\nThe tuple type is mapped to a JSON array of heterogenous types. So \nstd::tuple\nint, std::string, double\n maps to a JSON array of three element of type \nNumber\n, \nString\n, and \nNumber\n respectively.\n\n\nDuring parsing, only the prefix is matched. That is, if the JSON array is longer than the tuple size, the extraneous part will be silently dropped; if the JSON array is shorter than the tuple size, the not-mapped element simply remains untouched. This design is based on the assumption that when you need a heterogeneous array, you probably prioritize flexibility over strict conformance.\n\n\nDOM\n\n\nrapidjson::Document\n is the only DOM type supported. The envisioned use is to freely intermix static and dynamic typing. That is, part of a C++ struct is converted according to strict rules, while other part are flexibly handled.\n\n\nIn addition, you can convert any supported type to/from a DOM object directly. The relevant functions are surprisingly named \nautojsoncxx::to_document\n and \nautojsoncxx::from_document\n.", 
            "title": "Type support"
        }, 
        {
            "location": "/user_guide/type_support/#type-support", 
            "text": "", 
            "title": "Type support"
        }, 
        {
            "location": "/user_guide/type_support/#predefined-types", 
            "text": "", 
            "title": "Predefined types"
        }, 
        {
            "location": "/user_guide/type_support/#standard-library", 
            "text": "These types are supported by this library:   Basic types:  bool ,  char ,  int ,  unsigned int ,  long long ,  unsigned long long ,  std::string  Array types:  std::vector ,  std::deque ,  std::array ,  std::tuple  (this one needs special care)  Nullable types:  std::nullptr_t ,  std::unique_ptr ,  std::shared_ptr  Map types:  std::map ,  std::unordered_map ,  std::multimap ,  std::unordered_multimap  (The key must be of string type)  Object types: any class generated by the script  autojsoncxx.py .  DOM:  rapidjson::Document   Notes:    char  is mapped to JSON  Boolean  type, the same as  bool .", 
            "title": "Standard library"
        }, 
        {
            "location": "/user_guide/type_support/#boost", 
            "text": "If you include  autojsoncxx/boost_types.hpp  (a relatively new  boost  is required), you will also get support for   Array types:  boost::container::vector ,  boost::container::deque ,  boost::array  Nullable types:  boost::shared_ptr ,  boost::optional  Map types:  boost::unordered_map ,  boost::unordered_multimap  (The key must be of string type)", 
            "title": "Boost"
        }, 
        {
            "location": "/user_guide/type_support/#caveat", 
            "text": "No raw pointer and reference types are supported. Use smart pointers instead . They do not convey any information about ownership, and will make correct memory management (especially by a code generator) much more difficult.", 
            "title": "Caveat"
        }, 
        {
            "location": "/user_guide/type_support/#nested-types", 
            "text": "The supported types can be arbitrarily nested, for example  #define AUTOJSONCXX_MODERN_COMPILER 1 \n#include  iostream \n#include  person.hpp \n\nint main()\n{\n    auto test = std::make_tuple(std::vector std::string {  A ,  BC ,  DEF  }, nullptr,\n                                3.1415926, -223, std::shared_ptr int (),\n                                std::map std::string, bool { {  a , true }, \n                                                           {  \u0394 , false } },\n                                std::make_shared std::array Person, 2 ());\n\n    std::string str;\n\n    // This requires true variadic template support \n    // MSVC 2012 has std::tuple , but it is faked with macros\n    // Avoid std::tuple  if your compiler is not strong enough\n    autojsoncxx::to_pretty_json_string(str, test);\n\n    std::cout   str   '\\n';\n    return 0;\n}  Sample output  [\n    [\n         A ,\n         BC ,\n         DEF \n    ],\n    null,\n    3.1415926,\n    -223,\n    null,\n    {\n         a : true,\n         \u0394 : false\n    },\n    [\n        {\n             ID : 0,\n             name :  anonymous ,\n             height : 0.0,\n             weight : 0.0,\n             known_associates : []\n        },\n        {\n             ID : 0,\n             name :  anonymous ,\n             height : 0.0,\n             weight : 0.0,\n             known_associates : []\n        }\n    ]\n]", 
            "title": "Nested types"
        }, 
        {
            "location": "/user_guide/type_support/#self-defined-type", 
            "text": "The core of the library is two template class,  SAXEventHandler  and  Serializer . The base templates are defined as:  namespace autojsoncxx {\n\n// The core handlers for parsing\ntemplate  class T \nclass SAXEventHandler;\n\n// Only the second parameter should be specialized\ntemplate  class Writer, class T \nstruct Serializer;\n\n}  Each of the full or partial specialization of these templates will add new type support to the library.   Writing the handler is somewhat difficult, because there are a multitude of errors that can result from a mismatched JSON. So there is some base classes provided, based on  Curiously Recurring Template Pattern . For primitive types, such as a simple variant of  int  and  bool , or string types ( QString ,  CString ,  icu::UnicodeString ,  YetAnotherStringThatIsSoMuchBetterThanTheRest ), derive from  BaseSAXEventHandler . There are also base classes for array type  VectorBaseSAXEventHandler , nullable type  NullableBaseSAXEventHandler , map type  MapBaseSAXEventHandler . If you implement your own string, you probably want to add map type support as well, because the default implementation is specialized on  std::string .  Writing the serializer is very easy, and one can easily figure it out by looking at the source code.", 
            "title": "Self defined type"
        }, 
        {
            "location": "/user_guide/type_support/#special-types", 
            "text": "", 
            "title": "Special types"
        }, 
        {
            "location": "/user_guide/type_support/#tuple", 
            "text": "There are only one tuple type supported  std::tuple  ( boost::tuple  is not supported). Implementing it requires true variadic templates. If you want to use it, you need to define both  AUTOJSONCXX_HAS_MODERN_TYPES  and  AUTOJSONCXX_HAS_VARIADIC_TEMPLATE  to be nonzero. The macro  AUTOJSONCXX_MODERN_COMPILER  automatically turns on both two.  The tuple type is mapped to a JSON array of heterogenous types. So  std::tuple int, std::string, double  maps to a JSON array of three element of type  Number ,  String , and  Number  respectively.  During parsing, only the prefix is matched. That is, if the JSON array is longer than the tuple size, the extraneous part will be silently dropped; if the JSON array is shorter than the tuple size, the not-mapped element simply remains untouched. This design is based on the assumption that when you need a heterogeneous array, you probably prioritize flexibility over strict conformance.", 
            "title": "Tuple"
        }, 
        {
            "location": "/user_guide/type_support/#dom", 
            "text": "rapidjson::Document  is the only DOM type supported. The envisioned use is to freely intermix static and dynamic typing. That is, part of a C++ struct is converted according to strict rules, while other part are flexibly handled.  In addition, you can convert any supported type to/from a DOM object directly. The relevant functions are surprisingly named  autojsoncxx::to_document  and  autojsoncxx::from_document .", 
            "title": "DOM"
        }
    ]
}